# Clean Code

## 2. 의미 있는 이름
### 그릇된 정보를 피하라
- 실제로 List가 아니라면 List라는 이름을 붙이지 않는 게 좋다. (컨테이너 명은 변수명에 넣지 않는 것이 바람직하다.)
- 일관성이 떨어지는 표기법은 그릇된 정보다.

### 의미 있게 구분하라
- 이미 있는 이름이라고 불용어를 추가하는 것은 어떠한 정보도 제공하지 못한다.

### 검색하기 쉬운 이름을 사용하라.
- 이름 길이는 범위 크기에 비례해야 한다 (?)
### 인코딩을 피하라
- 여기서의 인코딩은 어떤 것을 의미하는가 (?)
- 왜 예전에는 m_ 이라는 접두어를 넣었던 것인가 (?)
### 자신의 기억력을 자랑하지 마라
- 명료함이 최고다
#### 클래스 이름
- 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
- Manager, Processor, Data, Info 등과 같은 단어는 피하고 동사는 사용하지 않음
#### 메소드 이름
- 메소드 이름은 동사나 동사구가 적합하다.
- 생성자를 중복정의 (overload) 할 때는 정적 팩초리 메소드를 사용한다.
    ```java
    Complex fulcrunPoint = Complex.FromRealNumber(23.0)
    ```
    ```java
    Complex fulcrunPoint = new Complex(23.0)
    ```
    - 위 예제가 아래 예제보다 좋다.
### 한 개념에 한 단어를 사용하라
- Controller, Manager, Driver 를 섞에 쓰면 혼란스럽다. 
- 일관성 있는 어휘가 중요하다.
### 말장난을 하지 마라
- 한 단어를 두 가지 목적으로 사용하지 마라. 
- 예) add 라는 메소드가 다른 목적으로 (집합에 수를 추가 하는) 생성이 된다면 기존에 add 가 있기 때문에 insert, append 등으로 대체한다.

## 3. 함수
### 작게 만들어라!
- 함수는 짧고 작을 수록 좋다, 얼마나? 2,3,4 줄 이다 !
#### 블록과 들여쓰기
- if, /else, while 문 등에 들어가는 블록은 한 줄이어야 한다는 것이다.
- 함수의 들여쓰기는 1,2 단이 적절하다.
### 한 가지만 해라!
- 함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야 한다.
### 함수 인수
#### 많이 쓰는 단항 형식
- 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. 
#### 플래그 인수
- 플래그 인수는 추하다. 함수가 대놓고 여러 가지를 처리한다고 공표하는 셈이니까!
### 출력 인수
- 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.
## 4. 주석
- 코드로 의도를 살리지 못해, 그러니까 실패를 만회하기 위해서 주석을 사용한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 주석을 사용한다.
- 주석은 오래될수록 코드와 멀어진다. 프로그래머들이 주석을 유지하고 보수하기란 현식적으로 불가능하다. 그렇기에 애초에 주석이 필요 없는 방향으로 에너지를 쏟는게 훨씬 낫다.
### 주석은 나쁜 코드를 보완하지 못한다.
- 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
-모듈의 짜임새가 엉망이고 지저분할 때 스스로가 "이런! 주석을 달아야 겠군" 한다. 
- 애초에 난장판을 깨끗이 치우려는 시간을 써라.
### 코드로 의돌르 표현하라!
- 개발자는 기본적으로 코드만으로 의도를 설명하기 어려운 경우를 코드는 휼륭한 수단이 아니라고 생각을 한다.
- 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.
### 좋은 주석
- 좋은 주석의 예를 설명한다. 
#### 법적인 주석
- 저작권, 표준 라이선스 등을 명시
#### 정보를 제공하는 주석
- 기본적인 정보를 제공하면 편리하다. 하지만 가능하다면 함수 이름에 정보를 담는 편이 좋다.
#### 의도를 설명하는 주석
- 자기 객체라는 의미가 WikiPagePath 타입을 의미하는 것인가 (?)
#### 의미를 명료하게 밝히는 주석
- 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용함
- 그러나 주석이 올바른지 검증을 하기 쉽지 않다. 
#### 결과를 경고하는 주석
- 때로는 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.
#### TODO 주석
- TODO 주석을 사용하면 편리하다. 하지만 어떤 용도로 사용하든 시스템에 나쁜 코드를 남겨 놓는 핑계가 되어서는 안된다.
### 나쁜 주석
- 대다수 주석이 이 범주에 속한다.
#### 주절거리는 주석
- 주석을 달기로 결정했다면 충분한 시간을 들여서 최고의 주석을 달도록 노력한다.
#### 같은 이야기를 중복하는 주석
- 코드보다 읽기가 쉽지도 않으며 코드보다 부정확해서 독자가 함수를 대충 이해하고 넘어가게 만든다.
- 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못한다.
#### 의무적으로 다는 주석
- 모든 함수에 javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지 없다.
#### 있으나 마나 한 주석
- 당연한 주석은 지나친 참견이라 개발자가 주석을 무시하는 습관에 빠져 코드가 바뀌면서 주석은 거짖말로 변한다.
- 있으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리해라.


## 5. 형식 맞추기
### 종속 함수
- 상수가 적절하지 않은 저차원 함수에 묻힌다 (?)
### 세로 순서
- 좋은 예 15-5(338쪽), 3-7(62쪽)
### 가로 공백과 밀집도
- 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다.
- 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않은 이유는 서로 밀접하기 때문이다.
## 6. 객체와 자료구조
### 자료 추상화
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. 구현을 감추려면 추상화가 필요하다.
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
- 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.
- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 밥법을 심각하게 고민해야 한다 !
### 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. -> 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. -> 새로운 자료구조를 추가하디 어렵다. 
- 새로운 자료 타입이 필요한 경우 객체지향 기법이 적합
- 반면 새로운 함수가 필요한 경우는 절차적인 자료구조가 적합
### 디미터 법칙
- 잘 이해가 가질 않음 (?)

## 10. 클래스
- 더 차원이 높은 단계까지 신경쓰지 않으면 깨끗한 코드를 얻기는 어렵다. 
### 클래스 체계
#### 캡슐화
### 클래스는 작아야 한다!
- 클래스는 클래스가 맡은 책임으로 클래스의 크기를 측정할 수 있다.
- 클래스 이름은 해당 클래스 책임을 기술해야 한다. -> 작명이 클래스 크기를 줄이는 첫 번째 관문이다.
- 모호한 단어가 있다면 클래스에다 여러 책임을 떠안겼다는 증거다. 
#### 단일 책임 원칙
- 클래스나 모듈을 변경할 이유가 아나, 단 하나뿐이어야 한다는 원칙이다. 
- 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다 (?)
- 규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하기 때문에 체계적인 정리가 필수다.
    - 그래야 직접 영향이 미치는 컴포넌트만 이해해도 충분하다.
    - 큼직한 다목적 클래스 몇 개로 이루어진 시스템은 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.
#### 응집도
- 클래스는 인스턴스 변수 수가 작아아 한다.
- 모든 인스턴스 변수를 메서드 마다 사용하는 클래스는 응집도가 높다.
- 일반적으로 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않지만 우리는 그것을 선호한다.
    - 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문
- '함수를 작게, 매개변수 목록을 짧게 라는 전략을 따르다 보면 때때로 몇몇 메서드 만이 사용하는  인스턴스 변수가 아주 많아진다.
    - 매개 변수가 없으니 인스턴수 변수가 많아지는 것인가?
    - 그래서 인수턴스 변수가 많아지니 하는 일이 많아지는 것인가?
#### 응집도를 유지하면 작은 클래스가 여럿이 나온다.
- 클래스가 응집력을 잃는 다면 쪼개라 !
### 변경하기 쉬운 클래스
- 대다수의 시스템은 지속적인 변경이 가해지는대 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다.
- update 문을 지워할 시점이 오면 클래스에 '손대어' 고쳐야 한다.
- 클래스에 손대는 순간 설계를 개선하려는 고민과 시도가 필요하다.
- OCP (클래스는 확장에 개방적이고 수정에 폐쇄적이어어야 한다)지원한다.
- 새 기능을 수정하거나 기존 기능 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.
### 변경으로부터 격리
- 요구 사항에 따라 코드도 변하기 마련이다. 
    - 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 
    - 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다. 
- 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다. 
    - 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리가 되어 있다는 의미다.