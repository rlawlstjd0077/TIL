## 자바 스레드

- JVM 스레드는 OS 스레드와 1:1 로 매핑됨
  - JVM스레드는 OS 스레드를 얇게 덧씌워 만든 것 이라 볼 수 있음
- OS는 범용적인 스케줄링을 사용하는데 (그래서 느림) OS는 JVM 내부에 대해 아무 것도알지 못한다.
- 스레드를 만들고 스레드 간을 오가는 작업은 커널을 거쳐야 하므로 비용이 많이 든다.
- OS 의 continuation 구현체는 자바 콜 스택 뿐만 아니라 네이티브 콜 스택도 포함하며 자원을 많이 사용한다. 
- OS 스레드 개수는 CPU 코어 숫자에 의대 제약 받음
- 스레드 스택 메모리는 OS에 의해서 힙 외의 영역에 마련됨 

## 동시성 미사용

- 자원을 효율적으로 사용하지 못해서 실행 성능은 떨어진다. JVM 스레드는 하나의 OS 스레드를 사용하며 OS 스레드는 하나의 CPI 코어를 사용하므로 나머지 코어는 놀게 된다. 

## 네이티브 멀티 스레딩

- 멀티 스레딩에는 일반적으로 아래와 같은 난관이 있다. 
  - CPU 코어, 메모리 자원의 효율적인 이용
  - 세밀한 스레드 갯수 조절, 스레드 관리
  - 제어 흐름 컨텍스트 유실ㅇ
  - 실행 동기화
  - 디버깅 테스트

몇개까지가 동시에 실행이 가능한 스레드 개수인가 ?

- OS 스레드 개수가 어떻게 되는가 ?

## ExecutorService

- 자바 5 부터 도입된 기능
- 스레드 풀링을 통해서 새로운 스레드 생성 부담을 덜고 스레드를 로우 레벨로 다루는 부담을 덜어내는 것이 주된 목표였음 
- 태스크가 `ExecutorService` 에 submit 되면서 큐에 들어감
- 작업 가능한 스레드가 큐에서 태스크를 가져가 실행한다. 



- 이때 눈여겨 볼 점은 
  - JVM 스레드 갯수가 여전히 OS 스레드 갯수의 의해 제한을 받는다. 
  - 스레드 풀에서 스레드를 하나 가져가면 해당 스레드는 연산을 수행하지 않더라도 다른 곳에 사용되지 못하고 낭비된다.
  - `Future` 가 반환되므로 발전된 것 같아 보이지만 조립 (compose) 할 수 없으며, 반환값을 얻기 위해서 `get()` 을 호출하면 태스크가 완료될 때까지 블로킹 된다. 
- 앞선 예제와 거의 동일하지만 가장 큰 차이점은 스레드를 직접 생성하지 않는다는 점이다.
  -  태스크를 `ExecutorService` 에 submit 하는 방식으로 스레드 풀 생성, 관리를 `ExecutorService` 가 담당한다.
  - 종료 조건 동기화를 위해서 `join()` 을 사용하지 않고 반환되는 `Future` 의 `get()` 을 호출해서 값이 반환될 때까지 블로킹한다. 
- 재미있는 점은 이전 예졔와 비교하여 훨씬 나은 성능을 보여주고 있다는 것이다. 
- 다만 이때 풀 크기를 제대로 설정하지 않으면 데드락이 발생하기도 한다. 
  - UserFlow 내에서 여러 스레드를 사용하는 경우 스레드 가용 수가 다 차는 경우 스레드를 할당 할수가 없기 때문이다. 

- ExecutorService Queue 사이즈는 어느 정도가 적절한가 ?

## Fork/Join 프레임워크

- Java7에서 `ExecutorService` 기반으로 만들어진 Fork/Join 프레임워크가 도입됐다. 
- Fork/Join 프레임워크는 재귀적으로 더 작은 크기로 쪼갤 수 있는 태스크를 효율적으로 처리하기 위해서 만들어졌다. 
  - Fork/Join 프레임워크는 동시 실행헤 대해서 개발자가 제어할 수 있는 옵션이 더 적어 `ExecutorService` 는 여전히 사용되고 있다.
- `ExecutorService` 와 확연히 다른 점은 빼가기다.
- 스레드 풀에 있던 스레드 A가 과부하가 걸려서 A 스레드 내부 큐가 꽉 차 있을 때 스레드 풀에 있는 다른 스레드 B가 `ExecutorService` 의 메인 큐에 있는 태스크를 가져오는 대신에 과부하 걸린 스레드 A 내부 큐에 있는 태스크를 가져와서 처리할 수 있다. 

## CompletableFuture

- 자바 8에서 도입된 `CompletableFuture` 는 앞서 본 Fork/Join 프레임워크를 기반으로 만들어졌다. 

- 이전까지는 연산 결과를 모아서 (combine) 처리할 수 있는 메서드가 하나도 없었고, 에러 처리를 위한 방법도 없었던 `Future` 인터페이스 도입 이후로 오랫동안 기다려 왔던 진화가 `CompletableFuture` 에서 드디어 이루어졌다.

  - 개선된 함수형 프로그래밍 스타일 도입
  - 로직을 조립하고 결과를 모아서 처리하고, 비도익 연산 과정을 실행하고 에러 처리가 가능한 50여개의 메서드 추가
  - `CompletableFuture` 의 평문형 API 대부분은 뒤에 `Async` 접미사가 붙은 것과 붙지 않은 것, 2가지씩 짝지어져 있다. Async 접미사가 붙은 메서드는 해당 연을 다른 스레드에서 실행하려고 할 때 사용한다. 

  