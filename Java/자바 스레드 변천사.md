- 동시성과 병렬성의 차이 ?
- 프로그램에서 사용할 수 있는 최적의 자바 슬에드 개수는 사용할 수 있는 하드웨어 코어의 개수에 따라 달라진다. 
- Java Thread 가 OS 스레드를 직접 사용하는가 ?
- User 여러개 늘렸을 때 ?

## 자바 스레드

- JVM 스레드는 OS 스레드와 1:1 로 매핑됨 
  - JVM스레드는 OS 스레드를 얇게 덧씌워 만든 것 이라 볼 수 있음
- OS는 범용적인 스케줄링을 사용하는데 (그래서 느림) OS는 JVM 내부에 대해 아무 것도알지 못한다. 
- 스레드를 만들고 스레드 간을 오가는 작업은 커널을 거쳐야 하므로 비용이 많이 든다.
- OS 의 continuation 구현체는 자바 콜 스택 뿐만 아니라 네이티브 콜 스택도 포함하며 자원을 많이 사용한다. 
- OS 스레드 개수는 CPU 코어 숫자에 의햐 제약 받음
- 스레드 스택 메모리는 OS에 의해서 힙 외의 영역에 마련됨

![image-20211101001433682](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101001433682.png)

### Task

- 뒤 예제들은 모두 아래의 Task를 실행한다. 
  - 서비스 A 수행시간은 1000ms
  - 서비스 B 수행시간은 500ms 
  - Persist 작업은 300ms 
- 아래 예제 에서는 서비스 A + 서비스 B + (Persist * 3) 작업을 수행함
- No Concurrency
  - 요청 갯수 * (서비스A 처리 시간 + 서비스B 처리 시간 + 저장 횟수 * 저장 시간)
- Full Concurrency
  - Max(서비스A 처리 시간, 서비스B 처리 시간) + 저장 시간
- 서비스 처리나 저장에 필요한 시간은 단순하게 `Thread.sleep()`으로 구현함.

![image-20211101001545228](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101001545228.png)

## 동시성 미사용

- 자원을 효율적으로 사용하지 못해서 실행 성능은 떨어진다. JVM 스레드는 하나의 OS 스레드를 사용하며 OS 스레드는 하나의 CPI 코어를 사용하므로 나머지 코어는 놀게 된다. 

![image-20211101002036719](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101002036719.png)

![image-20211101002321682](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101002321682.png)

## 네이티브 멀티 스레딩

- 멀티 스레딩에는 일반적으로 아래와 같은 난관이 있다. 
  - CPU 코어, 메모리 자원의 효율적인 이용
  - 세밀한 스레드 갯수 조절, 스레드 관리
  - 제어 흐름 컨텍스트 유실
  - 실행 동기화 
  - 디버깅 테스트
- 반면에 실행 성능은 꽤 좋다. 스레드 생성과 컨텍스트 스위칭 비용이 있으므로 이상적인 수치인 1,300ms에는 못 미치지만 앞서 살펴본 ‘동시성 미사용’ 방식에 비하면 훨씬 좋다.

### F.T 

- 스레드를 무한정 생성할 수는 없다. 
- OS마다 다르며 64비트 시스템에서 스레드 하나 당 1MB의 메모리(스레드 스택에 사용되는 메모리)를 점유한다. 
- 요청 1000개, 30회 저장으로 설정하고 실행하면 33,000개의 스레드를 생성하려다가 Out Of Memory 에러가 발생한다.

![image-20211101002715037](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101002715037.png)

## ExecutorService

- 자바 5 부터 도입된 기능
- 스레드 풀링을 통해서 새로운 스레드 생성 부담을 덜고 스레드를 로우 레벨로 다루는 부담을 덜어내는 것이 주된 목표였음 
- 태스크가 `ExecutorService` 에 submit 되면서 큐에 들어감
- 작업 가능한 스레드가 큐에서 태스크를 가져가 실행한다. 

![image-20211101002910579](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101002910579.png)

- 이때 눈여겨 볼 점은 
  - JVM 스레드 갯수가 여전히 OS 스레드 갯수의 의해 제한을 받는다. 
  - 스레드 풀에서 스레드를 하나 가져가면 해당 스레드는 연산을 수행하지 않더라도 다른 곳에 사용되지 못하고 낭비된다.
  - `Future` 가 반환되므로 발전된 것 같아 보이지만 조립 (compose) 할 수 없으며, 반환값을 얻기 위해서 `get()` 을 호출하면 태스크가 완료될 때까지 블로킹 된다. 
- 앞선 예제와 거의 동일하지만 가장 큰 차이점은 스레드를 직접 생성하지 않는다는 점이다.
  -  태스크를 `ExecutorService` 에 submit 하는 방식으로 스레드 풀 생성, 관리를 `ExecutorService` 가 담당한다.
  - 종료 조건 동기화를 위해서 `join()` 을 사용하지 않고 반환되는 `Future` 의 `get()` 을 호출해서 값이 반환될 때까지 블로킹한다. 
- 재미있는 점은 이전 예졔와 비교하여 훨씬 나은 성능을 보여주고 있다는 것이다. 
- 다만 이때 풀 크기를 제대로 설정하지 않으면 데드락이 발생하기도 한다. 
  - UserFlow 내에서 여러 스레드를 사용하는 경우 스레드 가용 수가 다 차는 경우 스레드를 할당 할수가 없기 때문이다. 


![image-20211101003354423](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101003354423.png)

## Fork/Join 프레임워크

- Java7에서 `ExecutorService` 기반으로 만들어진 Fork/Join 프레임워크가 도입됐다. 
- Fork/Join 프레임워크는 재귀적으로 더 작은 크기로 쪼갤 수 있는 태스크를 효율적으로 처리하기 위해서 만들어졌다. 
  - Fork/Join 프레임워크는 동시 실행헤 대해서 개발자가 제어할 수 있는 옵션이 더 적어 `ExecutorService` 는 여전히 사용되고 있다.
- `ExecutorService` 와 확연히 다른 점은 빼가기다.

![image-20211101003533445](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101003533445.png)

- 스레드 풀에 있던 스레드 A가 과부하가 걸려서 A 스레드 내부 큐가 꽉 차 있을 때 스레드 풀에 있는 다른 스레드 B가 `ExecutorService` 의 메인 큐에 있는 태스크를 가져오는 대신에 과부하 걸린 스레드 A 내부 큐에 있는 태스크를 가져와서 처리할 수 있다. 
- 앞서 ‘ExecutorService’ 단원에서 해봤던 것처럼 이번에도 풀 크기를 10 정도로 잡게 잡고 실행해
  - 이번에는 Fork/Join 프레임워크의 작업 빼가기 기능 덕분에 데드락이 발생하지 완료된다. 
  - 하지만 Fork/Join 프레임워크를 사용한다고해서 데드락이 항상 발생하지 않는 것은 아니다. 
  - Fork/Join 프레임워크에서는 태스크가 어떤 방식으로 더 작은 태스크로 분할될 수 있는지에 따라 데드락 발생 여부가 정해진다.

![image-20211101003656043](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101003656043.png)

## CompletableFuture

- 자바 8에서 도입된 `CompletableFuture` 는 앞서 본 Fork/Join 프레임워크를 기반으로 만들어졌다. 

- 이전까지는 연산 결과를 모아서 (combine) 처리할 수 있는 메서드가 하나도 없었고, 에러 처리를 위한 방법도 없었던 `Future` 인터페이스 도입 이후로 오랫동안 기다려 왔던 진화가 `CompletableFuture` 에서 드디어 이루어졌다.

  - 개선된 함수형 프로그래밍 스타일 도입
  - 로직을 조립하고 결과를 모아서 처리하고, 비도익 연산 과정을 실행하고 에러 처리가 가능한 50여개의 메서드 추가
  - `CompletableFuture` 의 평문형 API 대부분은 뒤에 `Async` 접미사가 붙은 것과 붙지 않은 것, 2가지씩 짝지어져 있다. Async 접미사가 붙은 메서드는 해당 연을 다른 스레드에서 실행하려고 할 때 사용한다. 

![image-20211101003810899](/Users/kimjs/Library/Application Support/typora-user-images/image-20211101003810899.png)


## Reactive 

- `CompletableFuture` 가 진화하여 리액티브 방식이 되었다고 볼 수도 있지만 그 이상임
- 리액티브 프로그래밍의 주요 목표는 프로그램 구조를 비동기 이벤트 스트림으로 재구성하는 것이고 스레드 관리는 라이브러리/프레임워크에 위임한다. 
- 주목핳 점
  - 데이터를 발생시키는 `Observable`, 데이터를 소비하는 `Observer`, 스레드를 관리하는 `Scheduler` 의 삼위일체
  - 리액티브 방식을 도입하면 프로그램 흐름 전부가 리액티브 방식으로 같이 바뀌어야 한다는 점에서 전염성이 강함.
    - 일부 블로킹 코드가 남아 있다면 리액티브의 장점은 전혀 발휘되지 못한다. 
  - 리액티브 구현체도 여러가지임
    - 초창기에는 `RxJava` 가 있었고 최근은 `Reactor` 가 대세임.
- 리액티브는 유일하게 자바 언어 자체적으로 제공되지 않는 솔루션임.
  - 리액티브 코드의 테스트와 디버깅은 상당히 어렵지만 충분히 투자해볼만 하다.
- 리액티브 코딩 스타일을 마스터하면 지속적으로 발전하는 리액티브 지원 라이브러리의 도움에 힘입어 대단히 성능이 좋은 코드를 효율적으로 작성할 수 있다.