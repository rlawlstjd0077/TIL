# 우아한 객체지향

출처: https://www.youtube.com/watch?v=dJ5C4qRqAgA

- 설게는 코드를 어떻게 배치할 것인가에 대한 의사결정
- 핵심은 변경에 초점을 맞추는 것이 중요
  - 변경의 핵심은 의존성임

### 의존성

- 변경에 의해서 영향을 받을 수 있는 가능성

- 클래스 의존성

  - Associate (연관관계)
    - A → B로 갈 수 있는 것 (객체 참조)
    - 영구적으로 연결되는 관계
    - 협력을 위해 필요한 영구적인 탐색 구조
  - Dependency (의존관계)
    - 파라미터, 리턴 타입이 그 타입이 나오거나
    - 메소드에서 그 타입의 인스턴스를 생성하는 것
    - 일시적으로 협력을 하는 시점에 관계를 맺고 헤어지는 관계
  - Ingeritance (상속관계)
    - 구현이 바뀌었을 때 영향을 받는 것
  - Realization (실체화 관계)
    - 인터페이스의 오퍼레이터 시그니처가 바뀌었을 때 영향을 받는 것

- 패키지 의존성

  - 패키지에 포함된 클래스 사이의 의존성

- 좋은 의존성을 위한 설계 지침

  - 양방향 의존성을 피하라

  - 다중성이 적은 방향을 선택하라

    - X - Collection으로 객체를 관리하다보면 여러 상황이 발생할 수 있고 관리하기도 힘듬

      ```java
      class A {
      	private Collection<B> bs;
      }
      class B {
      }
      ```

    - O

      ```java
      class A {
      } 
      class B {
      	private A a;
      } - 
      ```

  - 의존성이 필요없다면 제거하라

  - 패키지 사이의 의존성 사이클(양방향 의존성)을 제거하라

### 예제

- 출처 - https://github.com/eternity-oop
- 개발이 어려운 것은 메모리 상에서 구동되는 동적인 구조 (객체가 생성되고, 메시지를 주고받고) 속에서는 시간이라는 개념이 들어가면서 변화무쌍한 가능성들을 정적인 코드로 담아내야 되기 때문이다.
- **동적인 비즈니스를 정적인 코드로 풀어내야 하기 때문에 어렵다.**
- 코드상에 인스턴스 변수, 메서드 파라미터를 추가할 때마다 객체간의 런타임의 협력을 할 것이라는 것을 이야기 한다.
- 관계에는 방향성이 필요하기 때문에 방향성의 결정이 중요하다.
  - DB는 그렇지 않다. FK로 잡아놓으면 어느 방향이든 갈수 있다.
- 어떻게 관계를 잡을 것인지는 런타임에 객체들이 어떻게 협력을 할 것인지에 따라 정해준다.

### 관계의 종류 결정하기

- 무언가를 참조할 때는 이유가 있어야 하고 (연관해야 되는 이유, 의존해야 되는 이유) 이는 런타임에 어떻게 협력하는가에 따라 달라진다.
- 개념과 구현을 매핑시키는 것은 오류다. 개념을 구현할 수 있는 방법은 매우 많다. (ex. 객체 참조)
- 메소드가 필요한 이유는 메시지를 받기 때문이다.
  - 그렇기 때문에 메시지를 결정한 후에 메소드를 결정해야 한다.
- 연관 관계 = 탐색 가능성
  - 어떤 객체에서 어떤 객체로 빈번하게 가야되는 경우 영구적으로 경로를 설정이 필요한 경우 설정
- 의존 관계
  - 협력을 위해서 일시적으로 필요한 경우 설정 (파라미터, 리턴타입, 지역변수)