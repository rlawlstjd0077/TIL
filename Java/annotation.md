# Annotation

- 애너테이션 자체에는 기능을 가지고 있지 않다.
- 어떤 징표, 표시를 해놓은 의미가 적당하다.
- 런타임 중에 알아내야 하는 값은 들어가지 못함
- 컴파일러 수준에서 해석되거나 완전히 정적인 가밧만 쓸 수 있다.
- Documentation을 해야 하기 때문에

### Retention

- 애노테이션을 언제까지 유지할 것인가?
- 기본값:
- 순서
  - SOURCE: 소스 코드에만 유지를 하겠다.(컴파일 시에만 쓰겠다) 컴파일 후에는 애노테이션에 대한 정보가 없어진다.
    - 정말 주석으로만 쓴 것으로 바이트 코드에 남아있지 않게 된다.
    - 예) @Override
  - CLASS: 애노테이션에 대한 정보를 클래스 파일에도 남겨두겠다.
    - 바이트 코드를 읽어들여 (ByteBuddy 사용) 쓸 수는 있다.
    - 이 경우 클래스 로더가 클래스에 대한 정보를 메모리에 적재를 할 때 애노테이션 정보를 누락시킨다. (그래서 리플렉션이 되지 않음)
  - RUNTIME
    - 리플렉션을 쓸 수가 있게 된다.
    - 리플렉션: 클래스로더가 읽어들인 정보를 기반으로 메모리에 들어와있는 정보를 읽는 것

### 어노테이션 프로세서

- ServiceLoader

  - 인터페이스가 있고 구현체는 각각 구현할 수 있다.

    ```java
    public interface HelloService() {
    	String hello();
    }
    ```

  - 구현체를 JAR 파일만 바꿔끼면 JAR 파일에 들어있는 구현체를 가져올 수 있다.

  - 이 구현체를 가져올 수 있는 것이 ServiceLoader이다.

  - JAR 파일 안에다가

  - META-INF/services 디렉터리를 만들고

    - Interface 경로로 txt 파일을 만든 후 구현체 경로를 적어주누다.

  - springboot의 autoconfigure 와 형태가 살짝 비슷함

- 