# 2021.02.15

# 배운 것

## 동등성과 동일성

### 동일성 (Identity)

- 비교대상인 두 인스턴스가 같은 인스턴스 인지를 비교하는 것
- 자바에서는 primitive type은 해당 변수의 값을, reference type의 경우는 인스턴스의 주소값을 `==` 연산자를 통해서 비교하는 것을 의미한다.

### 동등성 (Equality)

- 두 인스턴스가 같은 정보를 가지고 있는지를 비교하는 것
- 자바에서는 `equals` 메서드를 통해서 비교한다.
- 다만, `Object` 클래스의 equals 는 동일성 비교연산을 하고 있기 때문에 보통은 오버라이드 하여 동등성 비교를 한다.

## 프로토타입 스코프

### 스코프

- 존재할 수 있는 범위를 가리키는 말이다.
- 빈의 스코프는 빈 오브젝트가 만들어져 존재할 수 있는 범위이다.
- 빈 오브젝트는 스프링 컨테이너가 관리하기 때문에 대부분 정해진 범위의 끝까지 존재한다.

### 프로토타입 빈의 생명주기와 종속성

- IoC는 애플리케이션을 구성하는 핵심 오브젝트를 코드가 아니라 컨테이너가 관리한다는 기본 개념을 가진다.
  - 그래서 스프링이 관리하는 오브젝트인 빈은 그 생성과 다른 빈에 대한 의존관계 주입, DI, DL 제거에 이륵기 까지 모든 오브젝트의 생명주기를 컨테이너 관리함
- 그러나 프로토타입 빈은 위 IoC의 기본 원칙을 따르지 않는다.
  - 빈을 요청할 떄마다 컨테이너가 생서하고 초기화하고 DI까지 해주지만 빈을 제공하고 나면 컨테이너는 더 이상 빈 오브젝트를 관리하지 않음
  - 오브젝트를 가져간 빈이나 DI로 주입받은 다른 빈이 해당 오브젝트를 관리하게 됨

### 프로토타입 빈의 용도

- 코드에서 `new` 로 오브젝트를 생성하는 것을 대신하기 위해서 사용된다.
- 사용자의 요청별로 독립적인 정보나 작업 상태를 저장해둘 오브젝트를 만들 필요가 있다.
  - `new` 혹은 팩토리로 코드 안에서 오브젝트를 만들면 되긴 하지만 컨테이너가 오브젝트를 만들고 초기화 해줘야 하는 경우가 존재함
  - 바로 **DI 때문 즉,** 해당 오브젝트가 DI가 필요한 오브젝트라는 뜻
- 일일이 수동으로 수정자를 통해서 DI 해줄 필요 없이 컨테이너가 오브젝트를 만들게 하면 훨씬 편하다.
- 매번 새로운 오브젝트가 필요하면서 DI를 통해 다른 빈을 사용할 수 있어야 한다면 프로토타입 빈이 가장 적절한 선택이다.
- View Form으로 부터 넘어온 데이터를 중심으로 Customer 정보를 Dao로 부터 가져와야 하는 예제
  - `ServiceRequest` 오브젝트가 Dao 의존성을 가지게 되면서 데이터 중심의 개발이 된다.

```java
public void serviceRequestFormSubmit(HttpServletRequest request) {
	ServiceRequest serviceRequest = this.context.getBean(ServiceRequest.class);
	serviceRequest.setCustomerByCustomerNo(request.getParameter("custno"));
	...
}

@Component
@Scope("prototype")
public class ServiceRequest {
	Customer customer;
	
	@Autowired
	CustomerDao customerDao;

	public void setCustomerByCustomerNo(String customerNo) {
		this.customer = customerDao.findCustomerByNo(customerNo);
	}
}
```

- 프로토타입 빈이 DI 방식으로 사용되는 경우는 드물다.
  - 물론 DI 받는 빈마다 다른 오브젝트를 사용해야 하는 특별한 이유가 있다면 그때는 프로토타입 빈을 DI로 사용할 수있다.

## Application Architecture

- 출처: 토비의 스프링 9.3
- 아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다.
- 가장 단순한 정의를 보면 경계 안에 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것으로 이해할 수 있다.
- 아키텍처는 구조 내에서 일어나는 동적인 행위과 깊은 관련이 있다.

### 아키텍처와 SoC

- 애플리케이션을 구성하는 오브젝트들은 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다.

- 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다.ㅏ

  - 그리하여 분리된 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다.

- 이런식으로 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 '계층형 아키텍처' 라고 부른다.

- 보통 웹기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는 다고 하여 

  3계층 애플리케이션

  이라고 한다.

  - 물론 반드시는 아님
  - 각 계층을 좀 더 세분화해서 더 작은 단위의 계층으로 나눌 수도 있음

### 3계층 아키텍처와 수직 계층

- 3계층 아키텍처의 구성 요소
- 데이터 액세스 계층
  - 백엔드의 DB나 레거시 시스템과 연동
- 서비스 계층
  - 비즈니스 로직을 담당
- 프레젠테이션 계층
  - 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리

**데이터 액세스 계층**

- DAO 계층이라고도 불린다.
  - DAO 패턴을 보편적으로 사용하기 때문
- 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다.

**서비스 계층**

- 잘 만들어진 스프링 어플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.
  - POJO로 만들면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있음
- 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다.
  - 때로는 이외에 서버, 시스템 레벨에서 제공하는 **기반 서비스**를 활용할 떄도 있음
  - 웹 서비스와 같은 원격 호출 혹은 메일, 메시징 서비스를 이용하는 것
- 다만 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안된다.
  - 기반 서비스 계층의 인터페이스로만 접근 가능하게 해야 하며
  - 또는 AOP를 이용하여 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용하는 것을 권장함
- 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 엑세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.
- 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어있는 서비스 계층이어야 한다.

**프레젠테이션 계층**

- 매우 다양한 기술과 프레임워크의 조합을 가질 수 있기에 가장 복잡한 계층이다.
- 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP  프로토콜을 사용하는 서블릿이 바탕이 된다.
- 스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공한다.

### 계층형 아키텍처 설계의 원칙

- 각 계층은 응집독 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
  - 각 계층은 자신의 계층의 책임에만 충실해야 함
- 각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다.
  - 이때는 계층 레벨에 정의한 인터페이스를 통해서 요청하며 인터페이스 메소드에는 계층 기술이 최대한 드러나지 않게 해야 함
- 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다.
- 스프링의 DI는 오브젝트 사이의 관계를 다루기 때문에 계층 사이의 경계나 그 관계에 직접적으로 관여하지 않는다.
  - DI를 통해서 각 계층 간의 복잡한 관계를 가지지 않도록 DI 를 구성하는데도 주의해야 함

## Clean Architecture

- Web 등과 같은 UI의 조작을 Controller, Gateway 들과 연결되어 처리 되는 형식
- 외부 에서 내부로 향하는 의존성의 방향들을 관리 해주는 것
- Use Case 가 Application Layer의 Service가 하는 일과 같았다.
  - 다만 Service는 DDD 에서 service, domain, infra 에서 모두 있을 수 있기 때문에 이를 구분해주기 위해서 application layer service라고 명시하기도 한다.
- Service 에서는 도메인 객체를 활용한다.
- 도메인을 관리하는 것 조차도 도메인 Layer에서 해주자는 취지로 repository 라고 부르는 곳에서 관리해주게 된다.
- 복잡한 도메인 관리를 repository로 넘기는 것이다.
- 엔티티는 indentifier 로 동일성을 보장해주고 된다.

### Repository

- 데이터에 접근하는 것을 캡슐화한다.
- 복잡한 데이터를 접근하는 것을 숨기고 **컬렉션 처럼 다루게 한다.**
- 도메인 모델 계층에서 데이터에 접근하는데 필요한 기술과 인프라를 분리 한다.

### JPA

- 객체는 메모리의 주소를 가지고 있으면서 인스턴스 자체로 식별할 수 있지만 데이터베이스에 저장하는 순간 메모리를 사용할 수 없고 객체를 저장하기 위한 식별자가 필요하다.

### 트랜잭션

- DB에 여러 작업들을 할 수 있을 때 일련의 작업을 한 단위로 하여 Atomic 하게 실행하는 것
  - 실행 도중 실패했을 때 원래대로 돌아갈 수 있도록