# 2021-01-21

## 진행 내역

- Handler 에서 처리(switch 분기로)하던 로직을 'HttpRequestContext' 클래스로 분리
- HTTP Method 별 로직을 Controller 클래스로 각각 분리하여 전략 패턴(?) 으로 처리
- HTTP Request 관련 Magic Number 등 상수, Enum 으로 분리

## 느낀점

- 이번 작업에서는 각 클래스의 책임이 무엇인지 책임을 어떻게 분리할 것인지를 중점적으로 고민을 했었습니다. 클래스에 대해서 '최소한의 책임을 지게 하자' 라고 생각하니 막연하던 것이 조금은 감이 잡혀가는 것 같습니다.
- 진행을 하다보면 자꾸 답을 찾으려고 하는 것 같습니다. 오늘도 어제보다는 '조금 더 나은 쓰레기'(?)를 만들어가자는 생각을 가지려고 노력해봅니다 ..
- 중요한 것은 답을 찾는것이 아니라 이전보다는 조금 더 개선된 결과물을 만들어내는 것
  - 즉, 하는 만큼
- 능동적인 학습을 원했다.
- 과제의 의도를 넘겨짚어 생각하시는 것보다 어떤 것이 학습 효과가 좋을지를 우선하시는 것도 좋다고 생각합니다.
- 무너뜨리기 쉬운 코드를 만드는게 좋은 것 같다는 생각이 들엇다.

## 배운점

### Java Doc 주석

- 주석은 중복 없이 간결하게
  - ex) `The class {@code TaskManager} is managing tasks.`
- JavaDoc Summary가 되는 첫 번째 문장은 끝에 마침표를 찍어준다.

### ETC

- 비어있지 않으면 .. 보다는 있으면이 더 읽기가 좋다.
  - 부정문은 한 번 더 생각해야되서 대부분의 경우 긍정문을 사용하는게 좋습니다.

### 토비's Spring 예외처리

- 예외를 잡고 아무 것도 하지 않는 것은 연습 중에도 절대로 만들어서는 안되는 코드이다.

  - 습관이 들지 않도록 조심하자.

  ```java
  try {
  	...
  } catch (SQLException e) {
  }
  ```

- 화면에 단지 예외를 출력하는건 예외를 처리한 것이 아니다.

  ```java
  } catch (SQLException e) {
  	System.out.println(e);
  }
  
  } catch (SQLException e) {
  	e.printStackTrace();
  }
  ```

- 예외를 처리할 때 반드시 지켜야 할 핵심 원칙 한가지는 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되야 한다.

  ```java
  //차라리 이게 났다.
  } catch (SQLException e) {
  	e.printStackTrace();
  	System.exit(1);
  }
  ```

- 자바의 예외 종류와 특징

  - Error

    - ```
      java.lang.Error
      ```

       클래스의 서브 클래스들로 시스템에 뭔가 비정상적인 상화아이 발생했을 경우에 사용된다.

      - 그래서 주로 자바 VM에서 발생시키기 때문에 애플리케이션 코드에서 잡으려고 하면 안됨
      - `OutOfMemoryError`, `ThreadDeath`

  - Exception과 체크 예외

    - `java.lang.Exception` 클래스와 서브 클래스로 정의되며 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용됨
    - 체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.
    - 자바 언어와 JDK 초기 설계자들은 체크 예외를 발생 가능한 예외에 모두 적용하려고 했던 것 같다.
      - `IOException` 과 `SQLException` 을 비롯해서 예외적인 상황에서 던져질 가능성이 있는 것들이 전부 체크 예외로 만들어져 있음

  - RuntimeException과 언체크/런타임 예외

    - 필수적으로 예외를 처리해줄 필요도 없으며 명시적으로 잡거나 throw 해줘도 상관없다.
    - 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다.
      - `NullPpinterException` 과 `IllegalArgumentException` 등

- 그러나 체크 예외의 불필요성을 주장하는 사람들이 늘어갔다.

  - 복구할 가능성이 조금이라도 있는, 예외적인 상황이기에 강제를 하지만,
  - 체크예외가 예외처리를 강제하는 것 때문에 예외 블랙홀이나 무책임한 throws 같은 코드가 남발되었다.

- 예외 처리 방법과 종류

  - 예외 복구

    - 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
    - 예) 서버의 접속이 가끔 안되는 DB 접속 서비스의 경우 재시도를 해볼 수 있음

  - 예리 회피

    - 예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
    - throw 문으로 선언하거나 catch 문으로 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는 것
    - 예외를 복구하거나 회피하는 것은 의도가 분명히 있어야 한다.
    - 긴밀한 역할을 분담하고 있는 관계가 아니라면 자신의 코드에서 발생하는 예외를 그냥 던져버리는 것은 무책임한 회피일 수 있다.

  - 예외 전환

    - 예외를 메소드 밖으로 던지는 것으로 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다.

    - 보통 전환하는 예외에는 원래 발생한 예외를 담아서 중첩예외를 만드는 것이 좋다.

      ```java
      catch(SQLException e) {
      	...
      	throw DuplicateUserIdException(e);
      }
      
      catch(SQLException e) {
      	...
      	throw DuplicateUserIdException().initCause(e);
      }
      ```

- 어차피 복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야 한다.

  - 대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공함

- 예외처리 전략

  - 런타임 예외의 보편화
    - 자바가 처음 만들어질 때 많이 사용되던 애플릿이나 AWS, 스윙을 사용한 독립 애플리케이션에서는 통제 불가능한 시스템 예외라고 할지라도 애플리케이셔ㄴ의 작업이 중단되지 않게 해주고 상황을 복구해줘야 했다.
    - 자바 엔터프라이즈 환경은 다른데, 수많은 사용자가 동시에 요청을 보내고 각 요청이 독립적인 작업으로 취급된다. 하나의 요청에서 예외가 발생하면 해당 작업만 중단시키면 그만이다.
      - 그래서 차라리 애플리케이션 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 게 좋다.
      - 또는 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 해당 요청의 작업을 취소하고 서버 관리자나 개바라자에게 통보해주는 편이 낫다.
      - 자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있는데 (throw Exception 으로 점철된 아무런 의미도 없는 메소드들을 낳을 뿐) 그래서 대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는게 낫다.
    - 자바 초기부터 있었던 JDK의 API와 달리 최근 등장하는 표준 스펙, 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의하고 잇다.
      - 언체크 예외라도 언제든 필요하면 catch 블록으로 잡을 수 있기 때문
  - 복구가 불가능한 예외라면 런타임 예외로 전환하여 던지는 것이 낫다. 다만 이때는 메소드에 Exception을 던진하는 사실을 표시해줘야 한다.
    - 런타임 예외를 사용하는 경우에는 API 문서나 레퍼런스 문서 등을 통해, 메소드를 사용할 때 발생할 수 있는 예외의 종류와 원인, 활용 방법을 자세히 설명해두는 것이 좋다.
  - 런타임 예외 = 낙관적인 예외처리 기법
    - 복구할 수 있는 예외는 없다고 가정하며 예외가 생겨도 **어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고**
  - 애플리케이션 예외
    - 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch해서 무엇인가 조치를 취하도록 요구하는 예외를 뜻한다.
    - 예외 상황을 처리하는 것이 차라리 예외를 던지고 처리하는 것이 더 명확한 경우에 사용
      - 예) 출금 시에 잔고가 부족한 경우
      - 이때는 잊지 않게 하기 위해서 체크 예외로 선언해준다.
  - 스프링의 API 메소드의 정의되어 있는 대부분의 예외는 런타임 예외로 강제하지 않는다.

- 대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것이지만 그렇다고 모든 예외를 다 무시해야 하는 건 아니다. 중복 키 처럼 비즈니스 로직에서 의미 있게 처리할 수 있는 예외도 있다.